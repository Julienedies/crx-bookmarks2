{"version":3,"file":"common.js","sources":["webpack:///./libs/db.js","webpack:///./mixins/index.js","webpack:///./libs/chrome/wrapApi.js","webpack:///./libs/chrome/downloads.js","webpack:///./libs/chrome/bookmarks.js","webpack:///./vendor/vueex/src/libs/draggable/index.js","webpack:///./vendor/vueex/src/util/index.js","webpack:///./vendor/vueex/index.js","webpack:///./filters/index.js","webpack:///./directives/toggle.js","webpack:///./app/install.js","webpack:///./vuex/modules/ui.js","webpack:///./vuex/index.js"],"sourcesContent":["/*!\n * 管理数据存储\n * Created by j on 2019-01-12.\n */\n\nimport EventEmitter from 'events'\n\nimport { storage } from './chrome/index'\n\nconst emitter = new EventEmitter()\n\nwindow.addEventListener('storage', (event) => {\n    console.log('window.storage event', +new Date, event)\n    let {key, oldValue, newValue} = event\n    let e = ''\n    let arg = null\n    let obj = null\n    let name = key.split(/[^\\w]+/)[0]\n    if (!oldValue && newValue) {\n        e = 'add'\n        arg = newValue\n    } else if (oldValue && !newValue) {\n        e = 'remove'\n        arg = oldValue\n    } else if (oldValue && newValue) {\n        e = 'change'\n        arg = newValue\n    }\n\n    try {\n        obj = JSON.parse(arg)\n    } catch (e) {\n        console.log(e)\n        obj = null\n    }\n    LISTENER.forEach(o => {\n        if (o.namespace === name) {\n            o.emit(e, obj || arg, event)\n        }\n    })\n})\n\nconst LISTENER = []\n\nfunction removeFormArray (value, array) {\n    let index = array.findIndex(item => item === value)\n    if (typeof index === 'number') {\n        array.splice(index, 0)\n    }\n}\n\nclass Db {\n    static getAll () {\n        return JSON.parse(JSON.stringify(localStorage))\n    }\n\n    static init (data) {\n        Object.entries(data).forEach(arr => {\n            let key = arr[0]\n            let val = arr[1]\n            console.log(key, val)\n            localStorage.setItem(arr[0], arr[1])\n        })\n    }\n\n    static remove (key) {\n        localStorage.removeItem(key)\n    }\n\n    constructor (namespace) {\n        if (!(this instanceof Db)) return new Db(namespace)\n        this.namespace = namespace\n        this.separator = '.'\n        this._on = {}\n    }\n\n    on (eventName, listener) {\n        eventName = this._prefix(eventName)\n        if (!LISTENER.includes(this)) {\n            LISTENER.push(this)\n        }\n        this._on[eventName] = true\n        emitter.on(eventName, listener)\n    }\n\n    off (eventName, listener) {\n        eventName = this._prefix(eventName)\n        delete this._on[eventName]\n        if (Object.keys(this._on).length === 0) {\n            removeFormArray(this, LISTENER)\n        }\n        emitter.removeListener(eventName, listener)\n    }\n\n    emit (eventName, ...args) {\n        eventName = this._prefix(eventName)\n        let glob = this._prefix('*')\n        if (this._on[glob]) {\n            args.unshift(eventName)\n            emitter.emit(glob, args)\n        } else if (this._on[eventName]) {\n            args.push(eventName)\n            emitter.emit(eventName, args)\n        } else {\n            console.log('Not listener for ', eventName, args, this)\n        }\n    }\n\n    _prefix (val = '') {\n        return `${ this.namespace }${ this.separator }${ val }`\n    }\n}\n\n\nconst methods = {\n\n    get (record) {\n        let namespace = this._prefix()\n        let result = {}\n        let id = typeof record === 'object' ? record.id : record\n\n        if (id) {\n            return JSON.parse(localStorage.getItem(this._prefix(id)))\n        } else {\n            for (let i in localStorage) {\n                if (i.indexOf(namespace) === 0) {\n                    id = i.replace(namespace, '') || this.namespace\n                    result[id] = JSON.parse(localStorage[i])\n                }\n            }\n            return result\n        }\n    },\n\n    has (record) {\n        return this.get(record)\n    },\n\n    set (record) {\n        let id = record.id || Math.random().toFixed(8).replace('0.', '')\n        id = this._prefix(id)\n        localStorage.setItem(id, JSON.stringify(record))\n    },\n\n    remove (record) {\n        let id = typeof record === 'object' ? record.id : record\n        return localStorage.removeItem(this._prefix(id))\n    },\n\n    clear () {\n        let namespace = this._prefix()\n        for (let i in localStorage) {\n            if (i.indexOf(namespace) === 0) {\n                localStorage.removeItem(i)\n            }\n        }\n    },\n\n}\n\n// 包装一些方法到promise, 方便以后改变存储方式\nObject.keys(methods).forEach(method => {\n    Db.prototype[method] = function (...args) {\n        const that = this\n        const fn = methods[method]\n        return new Promise(function (resolve, reject) {\n            let result = fn.apply(that, args)\n            console.log(`Db ${ that.namespace } exec ${ method }; args => `, args,  'return =>', result)\n\n            let arg = args[0]\n            if (/remove/.test(method)) {\n                that.emit('remove', arg, result)\n            } else if (/set/.test(method)) {\n                that.emit('change', arg, result)\n            } else if (/clear/.test(method)) {\n                that.emit('clear', arg, result)\n            }\n            resolve(result)\n        })\n    }\n})\n\n\nexport default function getDb (namespace) {\n    return new Db(namespace)\n}\n\nexport { Db }\n","/*!\n * define Vue mixins\n * Created by j on 2019-01-13.\n */\nimport editBookmark from './editBookmark'\n\nexport default {\n    methods: {\n        editBookmark\n    },\n    watch: {\n        '$root.event' (newVal, oldVal) {\n            console.log('mixins watch $root.event', this.name)\n            this.getData && this.getData()\n        },\n        '$store.state.ui.list.reverse' (newVal) {\n            this.bookmarkArray && this.bookmarkArray.reverse()\n        },\n    }\n}\n","/*!\n * 一个工具函数, 用于生成chrome api相同接口的包装对象\n * 但是包装对象的接口支持promise,\n * 同时提供一个on方法, 添加事件监听器的简洁写法\n * example:\n * // 原生接口调用\n * chrome.tabs.getCurrent(tab => tab)\n * // 包装对象调用\n * const tabs = wrapApi(chrome.tabs)\n * tabs.getCurrent().then(tab => tab)\n * tabs.on('onCreated', tab => tab)\n *\n * Created by j on 2019-01-12.\n */\n\n/**\n * @todo 为chrome api生成一个包装对象\n * @param api {Object} 要包装的chrome api\n * @param wrapper {Object} 包装后的对象\n * @return {Object} wrapper\n */\nexport default function wrapApi (api, wrapper = {}) {\n\n    let events = wrapper.events = wrapper.events || []\n    wrapper.api = api\n\n    for (let [prop, value] of Object.entries(api)) {\n\n        // wrap methods of chrome api as promise\n        if (typeof value === 'function') {\n\n            wrapper[prop] = ((prop => {\n\n                return function (...args) {\n                    console.log(`chrome API Invoking => ${wrapper.name}.${prop}`, `args => ${args}`)\n                    return new Promise((resolve, reject) => {\n                        let call = (data) => {\n                            resolve(data)\n                        }\n                        args.push(call)\n                        api[prop].apply(api, args)\n                    })\n                }\n\n            }))(prop)\n        }\n        // 提出事件类型\n        else if (typeof value === 'object' && prop.startsWith('on')) {\n            events.push(prop)\n        }\n\n    }\n\n    /**\n     * @todo wrap addListener for chrome api\n     * @param event  {String|Array}\n     * @param callback {Function}\n     */\n    wrapper.on = function (event, callback) {\n        if (!callback) {\n            callback = event\n            event = undefined\n        }\n\n        let events = this.events\n        let api = this.api\n\n        event = event || events  // 如果没有提供事件名, 则默认监听所有事件\n        event = Array.isArray(event) ? event : [event]\n\n        let f = event.length > 1 ? 'unshift' : 'push' // 如果一次监听多个事件, 则把事件名附近到回调函数参数头部, 否则添加到末尾\n\n        event.forEach(eventName => {\n            console.log(`addListener for ${wrapper.name}.`, eventName)\n            events.includes(eventName) && api[eventName].addListener(function (...args) {\n                console.log(eventName, args)\n                args[f](eventName)\n                callback.apply(null, args)\n            })\n        })\n\n    }\n\n    return wrapper\n\n}\n\n\n","/*!\n * \n * Created by j on 2019-01-13.\n */\n\nimport wrapApi from './wrapApi'\n\nconst wrapper = wrapApi(chrome.downloads)\n\nexport default wrapper","/*!\n * chrome.bookmarks wrapper\n * Created by j on 2019-01-05.\n */\n\nimport wrapApi from './wrapApi'\n\nconst events = ['onCreated', 'onRemoved', 'onChanged', 'onMoved', 'onChildrenReordered', 'onImportBegan', 'onImportEnded']\n\nconst promise = wrapApi(chrome.bookmarks, {name: 'bookmarks'})\n\nconst api = {\n    on (eventName, listener) {\n        return promise.on(eventName, listener)\n    },\n    get (id) {\n        return promise.get(id)\n    },\n    add (bookmark) {\n        return this.create(bookmark)\n    },\n    create (bookmark) {\n        let bk = {}\n        bk.title = bookmark.title\n        bk.url = bookmark.url\n        if (bookmark.parentId) {\n            bk.parentId = bookmark.parentId\n        }\n        return promise.create(bk)\n    },\n    recover (bookmark) {\n        let bk = {}\n        bk.title = bookmark.title\n        bk.url = bookmark.url\n        bk.parentId = bookmark.parentId\n        bk.index = bookmark.index\n        return promise.create(bk)\n    },\n    remove (bookmark) {\n        if (bookmark.url) {\n            return promise.remove(bookmark.id)\n        } else {\n            return promise.removeTree(bookmark.id)\n        }\n    },\n    update (bookmark) {\n        let changes = {title: bookmark.title, url: bookmark.url}\n        return promise.update(bookmark.id, changes)\n    },\n    move (bookmark, destination) {\n        let id = typeof bookmark === 'object' ? bookmark.id : bookmark\n        return promise.move(id, destination)\n    },\n    getChildren (id) {\n        return promise.getChildren(id)\n    },\n    getTree (isOnlyFolder) {\n        return promise.getTree().then(tree => {\n            // 过滤书签树, 只保留文件夹\n            function filter (tree) {\n                let len = tree.length\n                while (len--) {\n                    let node = tree[len]\n                    if (node.children) {\n                        filter(node.children)\n                    } else {\n                        tree.splice(len, 1)\n                    }\n                }\n            }\n\n            isOnlyFolder && filter(tree)\n            return tree\n        })\n    },\n    getSubTree (id) {\n        return promise.getSubTree(id)\n    },\n    getRecent (size) {\n        return promise.getRecent(size || 100)\n    },\n    search (query) {\n        return promise.search(query)\n    }\n}\n\nexport default api\n\n\n\n","/*!\n * Making draggable objects\n * Created by j on 2019-01-15.\n */\n\nexport default class Draggable {\n\n    /**\n     * Making draggable objects\n     * @param dom {dom} dom element\n     * @param callback {Function} callback on dragging\n     */\n    constructor (dom, callback) {\n        if (!(this instanceof Draggable)) return new Draggable(dom, callback)\n        this.dom = dom\n        this.callback = callback\n        this.startX = 0\n        this.startY = 0\n        this.downEvent = null\n        this.moveEvent = null\n\n        const that = this\n        const elm = this.dom\n\n        const onDown = this.onDown = function (e) {\n            e.preventDefault();\n            this.downEvent = e\n            that.startX = e.clientX;\n            that.startY = e.clientY;\n\n            document.addEventListener('mousemove', onMove)\n            document.addEventListener('mouseup', onUp)\n            return false\n        }\n\n        const onMove = function (e) {\n            this.moveEvent = e\n            let moveX = e.clientX - that.startX;\n            let moveY = e.clientY - that.startY;\n\n            that.startX = e.clientX;\n            that.startY = e.clientY;\n\n            that.callback({moveX, moveY})\n            return false\n        }\n\n        const onUp = function (e) {\n            document.removeEventListener('mousemove', onMove)\n            document.removeEventListener('mouseup', onUp)\n        }\n        elm.addEventListener('mousedown', onDown, false)\n    }\n\n    destroy () {\n        this.dom.removeEventListener('mousedown', this.onDown)\n    }\n\n}\n\n\n","/*!\n * \n * Created by j on 2019-01-13.\n */\n\nconst $clone = (obj) => JSON.parse(JSON.stringify(obj))\n\nexport default {\n    $clone\n}\n\n","/*!\n * vue extension.\n * Created by j on 2019-01-11.\n */\n\nimport popup from './src/components/popup/popup.vue'\nimport contextmenu from './src/components/contextmenu/contextmenu.vue'\nimport dragResizeBar from './src/components/drag-resize-bar/index.vue'\n\nimport $msg from './src/components/message/index'\n\nimport util from './src/util/index.js'\n\nconst func = {\n    ...util,\n    $msg\n}\n\nconst components = {\n    contextmenu,\n    dragResizeBar,\n    popup\n}\n\nconst install = function (Vue, opts = {}) {\n    const vp = Vue.prototype\n\n    Object.keys(func).forEach((name) => {\n        let fn = func[name]\n        let alias = opts.alias && opts.alias[name]\n        name = alias || name\n        if (Vue.prototype[name]) {\n            throw new Error(`命名冲突, Vue.prototype.${ name }已经存在, 可以通过options.alias.${ name }={rename}重新命名.`)\n        } else {\n            Vue.prototype[name] = fn\n        }\n    })\n\n    // register components on global\n    Object.keys(components).forEach(key => {\n        Vue.component(key, components[key])\n    })\n\n}\n\n\nconst API = {\n    install\n}\n\nexport default API\n\nexport {\n    popup\n}","/*!\n * filter\n * Created by j on 2019-01-05.\n */\n\n/**\n * 显示网站icon\n * @param input {String} 书签的url\n * @returns {String}  icon src\n */\nexport function getFavicon(input) {\n    return 'chrome://favicon/' + input;\n}\n\n","/*!\n * \n * Created by j on 2019-01-09.\n */\n\nexport default {\n    bind(el, binding, vnode, oldVnode) {\n\n    },\n    inserted(el, binding, vnode, oldVnode) {\n        let cla = binding.value;\n        console.log(binding)\n        el.onclick = function (e) {\n            this.classList.toggle(cla)\n        }\n\n    },\n    update(el, binding, vnode, oldVnode) {\n\n    },\n    componentUpdated(el, binding, vnode, oldVnode) {\n\n    },\n    unbind(el, binding, vnode, oldVnode) {\n        el.onclick = undefined;\n    }\n}","/*!\n * register components in global\n * Created by j on 2019-01-26.\n */\n\nimport * as filters from '../filters'\nimport * as directives from '../directives'\n\nimport components from '../components/index'\n\nexport default function (Vue) {\n\n    Vue.filter('getFavicon', filters.getFavicon)\n    Vue.directive('toggle', directives.toggle)\n\n    Vue.prototype.$sortBookmarksBy = function sortBookmarksBy (bookmarkArray, sortBy) {\n        return bookmarkArray.sort((a, b) => {\n            //console.log(a)\n            if (sortBy === 'url') {\n                let reg = /^\\w+:\\/\\/\\/?([\\w.]+)/i\n                let urlA = a.url || ''\n                let urlB = b.url || ''\n                let x = urlA.match(reg) || []\n                let y = urlB.match(reg) || []\n                x = x[0] || ''\n                y = y[0] || ''\n                console.log(x, y)\n                return x === y ? 0 : x.length - y.length\n            }\n            if (sortBy === 'children') {\n                let x = a.children ? 0 : 1\n                let y = b.children ? 0 : 1\n                return x - y\n            }\n            return a[sortBy] - b[sortBy]\n        })\n    }\n\n    Object.entries(components).forEach(([key, component]) => {\n        Vue.component(key, component)\n    })\n\n}","/*!\n * \n * Created by j on 2019-01-22.\n */\n\nconst state = {\n    list: {\n        reverse: false,\n        showType: 'list',\n        orderBy: 'index'\n    }\n}\n\nconst getters = {}\n\nconst mutations = {\n    updateUi (state, [key, value]) {\n        let keys = key.split('.')\n        let obj = state\n        while (keys.length >= 2) {\n            obj = obj[keys.shift()]\n        }\n        obj[keys.shift()] = value\n    }\n}\n\nconst actions = {}\n\nexport default {\n    state,\n    getters,\n    actions,\n    mutations\n}","/*!\n * \n * Created by j on 2019-01-07.\n */\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport modules from './modules/index'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    modules\n})"],"mappings":";;;;AASA;;;;ACHA;;;;;;;;;;;;;;ACeA;;;;ACdA;;;;ACAA;;;;;ACFA;;;ACEA;;;;;ACMA;;;;ACHA;;;;ACLA;;;;;;;;ACKA;;;;ACLA;;;;;ACIA","sourceRoot":""}